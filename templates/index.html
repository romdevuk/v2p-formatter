{% extends "base.html" %}

{% block content %}
<div class="app-container">
    <!-- Navigation Tabs -->
    <div style="margin-bottom: 30px; border-bottom: 2px solid #555;">
        <div style="display: flex; gap: 10px;">
            <a href="/v2p-formatter/" style="padding: 12px 24px; background: #1e1e1e; color: #667eea; text-decoration: none; border-radius: 6px 6px 0 0; border: 1px solid #667eea; border-bottom: none; font-weight: bold;">
                Video to Image
            </a>
            <a href="/v2p-formatter/media-converter" style="padding: 12px 24px; background: #2a2a2a; color: #e0e0e0; text-decoration: none; border-radius: 6px 6px 0 0; border: 1px solid #555; border-bottom: none;">
                Media Converter
            </a>
            <a href="/v2p-formatter/image-to-pdf" style="padding: 12px 24px; background: #2a2a2a; color: #e0e0e0; text-decoration: none; border-radius: 6px 6px 0 0; border: 1px solid #555; border-bottom: none;">
                Image to PDF
            </a>
            <a href="/v2p-formatter/deface" style="padding: 12px 24px; background: #2a2a2a; color: #e0e0e0; text-decoration: none; border-radius: 6px 6px 0 0; border: 1px solid #555; border-bottom: none;">
                Deface
            </a>
        </div>
    </div>

    <!-- Qualification/Learner Selection Section -->
    <section class="upload-section" style="margin-bottom: 20px;">
        <div style="display: flex; gap: 10px; align-items: center; flex-wrap: wrap; padding: 15px; background: #2a2a2a; border-radius: 6px; border: 1px solid #555;">
            <label style="color: #e0e0e0; font-size: 14px; white-space: nowrap;">Select Qualification:</label>
            <select id="qualificationSelect" style="flex: 1; min-width: 200px; padding: 8px 12px; background: #1e1e1e; color: #e0e0e0; border: 1px solid #555; border-radius: 4px; font-size: 14px;">
                <option value="">Select Qualification...</option>
                {% for qualification in qualifications %}
                <option value="{{ qualification }}" {% if qualification == selected_qualification %}selected{% endif %}>{{ qualification }}</option>
                {% endfor %}
            </select>
            <label style="color: #e0e0e0; font-size: 14px; white-space: nowrap;">Select Learner:</label>
            <select id="learnerSelect" style="flex: 1; min-width: 200px; padding: 8px 12px; background: #1e1e1e; color: #999; border: 1px solid #555; border-radius: 4px; font-size: 14px;" {% if not selected_qualification %}disabled{% endif %}>
                <option value="">Select Learner...</option>
                {% for learner in learners %}
                <option value="{{ learner }}" {% if learner == selected_learner %}selected{% endif %}>{{ learner }}</option>
                {% endfor %}
            </select>
            <button class="btn btn-secondary" onclick="loadFiles()" style="padding: 8px 16px;">üîÑ Refresh</button>
        </div>
    </section>
    
    <!-- Video Selection Section -->
    <section class="upload-section">
        <h2>1. Select Video</h2>
        
        <!-- Bulk Selection Controls -->
        <div id="bulkSelectionControls" style="margin-bottom: 15px; padding: 15px; background: #2a2a2a; border-radius: 6px; border: 1px solid #555;">
            <div style="display: flex; align-items: center; gap: 20px; flex-wrap: wrap;">
                <!-- Mode Toggle -->
                <div style="display: flex; align-items: center; gap: 10px;">
                    <label style="color: #e0e0e0; font-size: 14px; white-space: nowrap;">Mode:</label>
                    <label style="display: flex; align-items: center; cursor: pointer; user-select: none;">
                        <input type="checkbox" id="bulkModeToggle" style="margin-right: 8px; width: 18px; height: 18px; cursor: pointer;">
                        <span style="color: #e0e0e0; font-weight: 500;">Bulk Selection Mode</span>
                    </label>
                </div>
                
                <!-- Select All (visible only in bulk mode) -->
                <div id="selectAllContainer" style="display: none; display: flex; align-items: center; gap: 10px;">
                    <label style="display: flex; align-items: center; cursor: pointer; user-select: none;">
                        <input type="checkbox" id="selectAllCheckbox" style="margin-right: 8px; width: 18px; height: 18px; cursor: pointer;">
                        <span style="color: #e0e0e0; font-weight: 500;">Select All</span>
                    </label>
                </div>
                
                <!-- Selection Count Badge (visible only in bulk mode) -->
                <div id="selectionCountBadge" style="display: none; padding: 6px 12px; background: #667eea; color: white; border-radius: 20px; font-weight: bold; font-size: 14px;">
                    <span id="selectionCount">0</span> video(s) selected
                </div>
                
                <!-- Layout Options -->
                <div style="display: flex; align-items: center; gap: 10px; margin-left: auto;">
                    <label style="color: #e0e0e0; font-size: 14px; white-space: nowrap;">Sort by:</label>
                    <select id="sortBy" style="padding: 6px 12px; background: #1e1e1e; color: #e0e0e0; border: 1px solid #555; border-radius: 4px; font-size: 14px; cursor: pointer;">
                        <option value="name" selected>Name</option>
                        <option value="date">Date/Time</option>
                    </select>
                    <label style="color: #e0e0e0; font-size: 14px; white-space: nowrap;">Thumbnails per row:</label>
                    <select id="thumbnailsPerRow" style="padding: 6px 12px; background: #1e1e1e; color: #e0e0e0; border: 1px solid #555; border-radius: 4px; font-size: 14px; cursor: pointer;">
                        <option value="3" selected>3</option>
                        <option value="4">4</option>
                    </select>
                </div>
            </div>
        </div>
        
        <div class="file-selector-container">
            <div id="fileTree" class="file-tree" style="margin-top: 20px; max-height: 600px; overflow-y: auto; border: 1px solid #555; border-radius: 6px; padding: 15px; background: #1e1e1e;">
                <div id="fileTreeContent">
                    <p style="text-align: center; color: #999; padding: 20px;">Loading MP4 files...</p>
                </div>
            </div>
            <div id="fileTreeLoading" style="display: none; margin-top: 20px; text-align: center; color: #999;">
                <p>Scanning input directory for MP4 files...</p>
            </div>
        </div>
        <div id="uploadStatus" class="status-message"></div>
        <div id="debugOutput" style="background: #1e1e1e; padding: 10px; margin-top: 10px; border-radius: 5px; font-family: monospace; font-size: 12px; max-height: 300px; overflow-y: auto; border: 2px solid #555; color: #e0e0e0;">
            <strong style="color: #e0e0e0;">üîç Debug Output:</strong>
            <button onclick="document.getElementById('debugMessages').innerHTML='';" style="float: right; padding: 2px 8px; font-size: 10px; background: #2a2a2a; color: #e0e0e0; border: 1px solid #555; border-radius: 4px; cursor: pointer;">Clear</button>
            <div id="debugMessages" style="margin-top: 10px;"></div>
        </div>
    </section>

    <!-- Time Selection Section -->
    <section class="time-section" id="timeSection" style="display: none;">
        <h2 id="timeSectionTitle">2. Select Time Points from Video</h2>
        <div id="batchModeIndicator" style="display: none; margin-bottom: 15px; padding: 12px; background: #2a3a4a; border-left: 4px solid #667eea; border-radius: 4px;">
            <strong style="color: #667eea;">üì¶ Batch Mode:</strong>
            <span id="batchModeInfo" style="color: #e0e0e0; margin-left: 8px;">Time points will be applied to all selected videos.</span>
        </div>
        <div class="video-container">
            <video id="videoPlayer" controls style="width: 100%; max-width: 800px; background: #000;"></video>
        </div>
        <div class="time-points-container" style="margin-top: 20px;">
            <div class="selected-times" id="selectedTimes">
                <p><strong>Selected Time Points (with previews):</strong></p>
                <div id="timePointsList" style="margin-top: 10px; min-height: 150px; padding: 15px; background: #1e1e1e; border-radius: 6px; border: 1px solid #444;"></div>
                <div style="margin-top: 15px; padding: 15px; background: #2a2a2a; border-radius: 6px; border: 1px solid #555;">
                    <div style="margin-bottom: 10px;">
                        <label for="autoShotsSelect" style="display: block; margin-bottom: 5px; font-weight: 500;">
                            <strong>Auto-generate time points:</strong>
                        </label>
                        <select id="autoShotsSelect" style="padding: 8px; border: 1px solid #555; border-radius: 4px; font-size: 14px; width: 200px; margin-right: 10px; background: #1e1e1e; color: #e0e0e0;">
                            <option value="">Manual (click to add)</option>
                            <option value="5">5 shots (evenly spaced)</option>
                            <option value="10">10 shots (evenly spaced)</option>
                            <option value="15">15 shots (evenly spaced)</option>
                            <option value="20">20 shots (evenly spaced)</option>
                            <option value="custom">Custom number...</option>
                        </select>
                        <input type="number" id="customShotsInput" min="1" max="100" placeholder="Number of shots" 
                               style="padding: 8px; border: 1px solid #555; border-radius: 4px; font-size: 14px; width: 150px; display: none; margin-right: 10px; background: #1e1e1e; color: #e0e0e0;">
                        <button class="btn btn-secondary" id="applyAutoShotsBtn" type="button" style="display: none;">Apply</button>
                    </div>
                    <div style="margin-top: 10px; padding-top: 10px; border-top: 1px solid #555;">
                        <button class="btn btn-secondary" id="addCurrentTimeBtn" type="button">+ Add Current Time</button>
                        <button class="btn btn-secondary" id="clearAllTimesBtn" type="button" style="margin-left: 10px;">Clear All</button>
                    </div>
                </div>
            </div>
        </div>
        <div class="video-info" id="videoInfo" style="margin-top: 15px;"></div>
    </section>

    <!-- Output Settings Section -->
    <section class="output-settings-section" id="outputSettingsSection" style="display: none;">
        <h2 id="outputSettingsTitle">3. Output Settings</h2>
        <div id="batchSettingsIndicator" style="display: none; margin-bottom: 15px; padding: 12px; background: #2a3a4a; border-left: 4px solid #667eea; border-radius: 4px;">
            <strong style="color: #667eea;">üì¶ Batch Mode:</strong>
            <span id="batchSettingsInfo" style="color: #e0e0e0; margin-left: 8px;">These settings will apply to all selected videos.</span>
        </div>
        <div class="settings-container">
            <div class="settings-group">
                <h3>Image Settings</h3>
                <div class="config-grid">
                    <div class="config-item">
                        <label for="qualitySlider">Quality: <span id="qualityValue">95</span></label>
                        <input type="range" id="qualitySlider" min="1" max="100" value="95">
                    </div>
                    <div class="config-item">
                        <label for="resolutionSelect">Resolution:</label>
                        <select id="resolutionSelect">
                            <option value="original">Original</option>
                            <option value="1920x1080">1920x1080</option>
                            <option value="1280x720">1280x720</option>
                            <option value="640x480" selected>640x480</option>
                        </select>
                    </div>
                </div>
            </div>
            <div class="settings-group">
                <h3>Output Format</h3>
                <div class="config-grid">
                    <div class="config-item">
                        <label for="outputFormat">Format:</label>
                        <select id="outputFormat">
                            <option value="both">Both (PDF + DOCX)</option>
                            <option value="pdf">PDF Only</option>
                            <option value="docx">DOCX Only</option>
                        </select>
                    </div>
                    <div class="config-item" id="pdfSettingsContainer">
                        <label for="layoutSelect">Layout:</label>
                        <select id="layoutSelect">
                            <option value="grid">Grid</option>
                            <option value="custom">Custom</option>
                        </select>
                    </div>
                    <div class="config-item" id="imagesPerPageContainer">
                        <label for="imagesPerPage">Images per Page:</label>
                        <select id="imagesPerPage">
                            <option value="1">1</option>
                            <option value="4" selected>4</option>
                            <option value="6">6</option>
                            <option value="9">9</option>
                        </select>
                    </div>
                </div>
            </div>
        </div>
        <p class="output-info" style="margin-top: 20px; padding: 15px; background-color: #2a2a2a; border: 1px solid #555; border-radius: 8px; color: #e0e0e0;">
            All generated files (images and PDFs) will be saved in the same directory as the selected video file.
        </p>
    </section>

    <!-- Processing Section -->
    <section class="processing-section" id="processingSection" style="display: none;">
        <h2>4. Process</h2>
        <div class="action-buttons">
            <button class="btn btn-primary" id="extractFramesBtn" type="button">Extract Frames</button>
            <button class="btn btn-primary" id="generateOutputBtn" type="button" style="display: none;">Generate PDF & DOCX</button>
        </div>
        
        <!-- Batch Progress Section -->
        <div id="batchProgressContainer" style="display: none; margin-top: 20px; padding: 20px; background: #2a2a2a; border-radius: 6px; border: 1px solid #555;">
            <h3 style="margin-top: 0; color: #e0e0e0;">Batch Processing Progress</h3>
            <div id="batchProgressBar" style="width: 100%; height: 30px; background: #1e1e1e; border-radius: 4px; overflow: hidden; margin-bottom: 15px; border: 1px solid #555;">
                <div id="batchProgressFill" style="height: 100%; background: linear-gradient(90deg, #667eea 0%, #764ba2 100%); width: 0%; transition: width 0.3s ease;"></div>
            </div>
            <div id="batchProgressText" style="color: #e0e0e0; margin-bottom: 15px; font-weight: 500;">Preparing...</div>
            
            <!-- Per-Video Status List -->
            <div id="batchVideoStatusList" style="max-height: 300px; overflow-y: auto; border: 1px solid #555; border-radius: 4px; padding: 10px; background: #1e1e1e;">
                <!-- Status items will be dynamically added here -->
            </div>
        </div>
        
        <div id="progressContainer" class="progress-container" style="display: none;">
            <div class="progress-bar">
                <div class="progress-fill" id="progressFill"></div>
            </div>
            <p id="progressText"></p>
        </div>
        <div id="results" class="results"></div>
    </section>
</div>

<script>
// GLOBAL STATE - SIMPLE AND DIRECT
window.appData = {
    videoPath: null,
    videoInfo: null,
    selectedTimes: [],
    extractedImages: [],
    
    // Bulk selection mode (initialized to prevent undefined errors)
    bulkMode: false,
    selectedVideos: [],           // Array of {path, name, info} for bulk mode
    currentBatchIndex: 0,
    batchResults: [],             // Results for each video in batch
    availableFiles: [],           // Available files list (for re-rendering)
    thumbnailsPerRow: 3,          // Number of thumbnails per row (3 or 4)
    sortBy: 'name'                // Sort order: 'name' (default) or 'date'
};

// Debug function
function debug(msg, type = 'info') {
    const msgs = document.getElementById('debugMessages');
    if (msgs) {
        const div = document.createElement('div');
        div.style.color = type === 'error' ? 'red' : type === 'success' ? 'green' : 'blue';
        div.textContent = `[${new Date().toLocaleTimeString()}] ${msg}`;
        msgs.appendChild(div);
        msgs.scrollTop = msgs.scrollHeight;
    }
    console.log(`[${type.toUpperCase()}]`, msg);
}

/**
 * Handle qualification dropdown change
 */
function handleQualificationChange() {
    const qualificationSelect = document.getElementById('qualificationSelect');
    const learnerSelect = document.getElementById('learnerSelect');
    
    if (!qualificationSelect || !learnerSelect) {
        return;
    }
    
    const qualification = qualificationSelect.value;
    
    // Clear learner selection
    learnerSelect.value = '';
    learnerSelect.disabled = true;
    learnerSelect.style.color = '#999';
    
    // Clear file tree
    document.getElementById('fileTreeContent').innerHTML = '<p style="text-align: center; color: #999; padding: 20px;">Please select a learner to view files</p>';
    
    if (qualification) {
        // Fetch learners for this qualification
        fetch(`/v2p-formatter/learners?qualification=${encodeURIComponent(qualification)}`)
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    populateLearnerDropdown(data.learners);
                } else {
                    debug('Error loading learners: ' + (data.error || 'Unknown'), 'error');
                }
            })
            .catch(err => {
                debug('Error: ' + err.message, 'error');
            });
    }
}

/**
 * Populate learner dropdown
 */
function populateLearnerDropdown(learners) {
    const learnerSelect = document.getElementById('learnerSelect');
    if (!learnerSelect) {
        return;
    }
    
    learnerSelect.innerHTML = '<option value="">Select Learner...</option>';
    
    learners.forEach(learner => {
        const option = document.createElement('option');
        option.value = learner;
        option.textContent = learner;
        learnerSelect.appendChild(option);
    });
    
    learnerSelect.disabled = false;
    learnerSelect.style.color = '#e0e0e0';
}

/**
 * Handle learner dropdown change
 */
function handleLearnerChange() {
    const qualificationSelect = document.getElementById('qualificationSelect');
    const learnerSelect = document.getElementById('learnerSelect');
    
    if (!qualificationSelect || !learnerSelect) {
        return;
    }
    
    const qualification = qualificationSelect.value;
    const learner = learnerSelect.value;
    
    // Auto-load files when both qualification and learner are selected
    if (qualification && learner) {
        // Update URL without reload
        const url = new URL(window.location);
        url.searchParams.set('qualification', qualification);
        url.searchParams.set('learner', learner);
        window.history.pushState({}, '', url);
        
        loadFiles();
    } else {
        // Clear file tree
        document.getElementById('fileTreeContent').innerHTML = '<p style="text-align: center; color: #999; padding: 20px;">Please select both qualification and learner to view files</p>';
    }
}

// Load files on page load
window.loadFiles = function() {
    debug('Loading files...', 'info');
    document.getElementById('fileTreeLoading').style.display = 'block';
    document.getElementById('fileTreeContent').innerHTML = '<p style="text-align: center; color: #999; padding: 20px;">Loading MP4 files...</p>';
    
    // Get qualification and learner from dropdowns or URL parameters
    const qualificationSelect = document.getElementById('qualificationSelect');
    const learnerSelect = document.getElementById('learnerSelect');
    const urlParams = new URLSearchParams(window.location.search);
    const qualification = (qualificationSelect && qualificationSelect.value) || urlParams.get('qualification') || '';
    const learner = (learnerSelect && learnerSelect.value) || urlParams.get('learner') || '';
    
    // Build URL with parameters
    let url = '/v2p-formatter/list_files';
    if (qualification && learner) {
        url += `?qualification=${encodeURIComponent(qualification)}&learner=${encodeURIComponent(learner)}`;
    }
    
    fetch(url)
        .then(r => r.json())
        .then(data => {
            document.getElementById('fileTreeLoading').style.display = 'none';
            
            if (data.success && data.files && data.files.length > 0) {
                // Store files for bulk selection
                window.appData.availableFiles = data.files;
                renderVideoList(data.files);
                debug(`Loaded ${data.files.length} file(s)`, 'success');
            } else {
                document.getElementById('fileTreeContent').innerHTML = '<p style="color: #999; padding: 20px; text-align: center;">No MP4 files found in input folder.</p>';
            }
        })
        .catch(err => {
            document.getElementById('fileTreeLoading').style.display = 'none';
            debug('Error loading files: ' + err.message, 'error');
            document.getElementById('fileTreeContent').innerHTML = `<p style="color: #ff6b6b; padding: 20px; text-align: center;">Error: ${err.message}</p>`;
        });
};

// Auto-load on page load only if URL parameters are present
(function() {
    const urlParams = new URLSearchParams(window.location.search);
    const hasQualification = urlParams.get('qualification');
    const hasLearner = urlParams.get('learner');
    
    // Only auto-load if both URL parameters are present (otherwise wait for DOMContentLoaded to set dropdowns)
    if (hasQualification && hasLearner) {
        if (document.readyState === 'loading') {
            // Wait for DOMContentLoaded to set dropdowns first
            document.addEventListener('DOMContentLoaded', function() {
                setTimeout(() => {
                    if (typeof window.loadFiles === 'function') {
                        window.loadFiles();
                    }
                }, 600);
            });
        } else {
            // DOM already loaded, but wait a bit for dropdowns to be set
            setTimeout(() => {
                if (typeof window.loadFiles === 'function') {
                    window.loadFiles();
                }
            }, 600);
        }
    }
})();

// Render video list with bulk selection support and folder structure
function renderVideoList(files) {
    const bulkMode = window.appData.bulkMode || false;
    const selectedVideos = window.appData.selectedVideos || [];
    const selectedPaths = selectedVideos.map(v => v.path);
    
    // Check for single mode selection (current video path)
    const currentVideoPath = window.appData.videoPath;
    
    // Get thumbnails per row setting - default to 3
    let thumbnailsPerRow = 3;
    if (window.appData && window.appData.thumbnailsPerRow) {
        const parsed = parseInt(window.appData.thumbnailsPerRow);
        if (!isNaN(parsed) && parsed > 0) {
            thumbnailsPerRow = parsed;
        }
    }
    if (thumbnailsPerRow < 3) {
        thumbnailsPerRow = 3;
    }
    
    // Get sort setting
    const sortBy = (window.appData && window.appData.sortBy) ? window.appData.sortBy : 'name';
    
    // Organize files by folder
    const folders = {};
    files.forEach(file => {
        const folder = file.folder === 'root' ? 'root' : file.folder;
        if (!folders[folder]) {
            folders[folder] = [];
        }
        folders[folder].push(file);
    });
    
    let html = '';
    
    // Render subfolders first (sorted) - all collapsed by default
    const subfolders = Object.keys(folders).filter(f => f !== 'root').sort();
    subfolders.forEach(folder => {
        html += renderVideoFolder(folder, folders[folder], thumbnailsPerRow, sortBy, bulkMode, selectedPaths, currentVideoPath);
    });
    
    // Render root videos last
    if (folders['root'] && folders['root'].length > 0) {
        if (subfolders.length > 0) {
            html += '<div style="margin-top: 20px; padding-top: 20px; border-top: 1px solid #555;"><strong style="color: #e0e0e0;">Direct videos:</strong></div>';
        }
        // Render root videos directly (not in a folder wrapper)
        html += `<div style="display: grid; grid-template-columns: repeat(${thumbnailsPerRow}, 1fr); gap: 16px; width: 100%;">`;
        const sortedRoot = sortFiles(folders['root'], sortBy);
        sortedRoot.forEach(file => {
            html += renderVideoItem(file, thumbnailsPerRow, bulkMode, selectedPaths, currentVideoPath);
        });
        html += '</div>';
    }
    
    document.getElementById('fileTreeContent').innerHTML = html;
    updateSelectionUI();
}

// Helper function to sort files
function sortFiles(files, sortBy) {
    const sorted = [...files];
    if (sortBy === 'date') {
        sorted.sort((a, b) => {
            const dateA = a.modified_time || a.created_time || 0;
            const dateB = b.modified_time || b.created_time || 0;
            if (dateA !== dateB) {
                return dateB - dateA; // Newest first
            }
            return a.name.localeCompare(b.name);
        });
    } else {
        sorted.sort((a, b) => a.name.localeCompare(b.name));
    }
    return sorted;
}

// Render video folder with collapsible structure
function renderVideoFolder(folderName, files, thumbnailsPerRow, sortBy, bulkMode, selectedPaths, currentVideoPath) {
    const folderId = 'folder-' + folderName.replace(/[^a-zA-Z0-9]/g, '-');
    const isCollapsed = true; // All folders collapsed by default
    
    let html = '';
    html += `<div class="video-folder" data-folder="${folderId}" style="width: 100%; margin-bottom: 20px;">`;
    html += `<div class="folder-header" onclick="toggleVideoFolder('${folderId}')" style="cursor: pointer; padding: 10px; margin: 5px 0; background: #2a2a2a; border-radius: 4px; display: flex; align-items: center; gap: 10px;">`;
    html += `<span class="folder-icon">${isCollapsed ? '‚ñ∂' : '‚ñº'}</span>`;
    html += `<strong style="color: #e0e0e0;">${escapeHtml(folderName)}</strong>`;
    html += `<span style="color: #666; margin-left: 10px;">(${files.length} videos)</span>`;
    html += `</div>`;
    html += `<div class="folder-content" id="${folderId}" style="display: ${isCollapsed ? 'none' : 'block'}; margin-top: 5px;">`;
    html += `<div style="display: grid; grid-template-columns: repeat(${thumbnailsPerRow}, 1fr); gap: 16px; width: 100%;">`;
    
    // Sort files
    const sortedFiles = sortFiles(files, sortBy);
    
    sortedFiles.forEach(file => {
        html += renderVideoItem(file, thumbnailsPerRow, bulkMode, selectedPaths, currentVideoPath);
    });
    
    html += `</div></div></div>`; // Close grid container, folder content, and folder
    
    return html;
}

// Render individual video item
function renderVideoItem(file, thumbnailsPerRow, bulkMode, selectedPaths, currentVideoPath) {
    const path = file.path.replace(/'/g, "&#39;").replace(/"/g, "&quot;");
    const name = file.name.replace(/'/g, "&#39;").replace(/"/g, "&quot;");
    const cacheKey = file.modified_time ? `m=${Math.floor(file.modified_time)}` : `t=${new Date().getTime()}`;
    const thumbnailUrl = `/v2p-formatter/thumbnail?path=${encodeURIComponent(file.path)}&size=240x180&${cacheKey}`;
    
    // Check if selected: either in bulk mode selection OR is current video in single mode
    const isSelected = bulkMode ? selectedPaths.includes(file.path) : (currentVideoPath === file.path);
    
    // Style based on selection state
    const bgColor = isSelected ? '#2a3a4a' : '#1e1e1e';
    const borderColor = isSelected ? '#667eea' : '#555';
    const borderWidth = isSelected ? '3px' : '2px';
    const boxShadow = isSelected ? '0 0 0 2px rgba(102, 126, 234, 0.3)' : 'none';
    
    // Escape path for use in JavaScript
    const jsPath = path.replace(/\\/g, '\\\\').replace(/'/g, "\\'");
    
    return `
        <div class="video-item ${isSelected ? 'selected' : ''}" 
             data-video-path="${path}" 
             data-video-name="${name}"
             onclick="handleVideoClick('${path}', '${name}')" 
             style="cursor: pointer; padding: 12px; border-radius: 8px; background: ${bgColor}; border: ${borderWidth} solid ${borderColor}; box-shadow: ${boxShadow}; transition: all 0.2s; position: relative; width: 100%; box-sizing: border-box;"
             onmouseover="if (!this.classList.contains('selected')) { this.style.background='#2a2a2a'; this.style.borderColor='#667eea'; }"
             onmouseout="checkVideoSelectionState(this, '${jsPath}');">
            ${isSelected ? `
                <div style="position: absolute; top: 8px; right: 8px; z-index: 10; background: #667eea; color: white; width: 28px; height: 28px; border-radius: 50%; display: flex; align-items: center; justify-content: center; font-weight: bold; font-size: 16px; border: 2px solid white; box-shadow: 0 2px 8px rgba(0,0,0,0.5);">‚úì</div>
            ` : ''}
            ${bulkMode ? `
                <div style="position: absolute; top: 8px; left: 8px; z-index: 10;">
                    <input type="checkbox" 
                           ${isSelected ? 'checked' : ''}
                           onclick="event.stopPropagation(); toggleVideoSelection('${path}', '${name}');"
                           style="width: 24px; height: 24px; cursor: pointer; accent-color: #667eea;">
                </div>
            ` : ''}
            <div style="width: 100%; padding-top: 75%; background: #1a1a1a; border-radius: 4px; overflow: hidden; position: relative; margin-bottom: 8px;">
                <img src="${thumbnailUrl}" 
                     alt="${file.name}" 
                     style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; object-fit: contain;"
                     onerror="this.style.display='none'; this.nextElementSibling.style.display='flex';"
                     onload="this.nextElementSibling.style.display='none';">
                <div style="display: none; position: absolute; top: 0; left: 0; width: 100%; height: 100%; flex-direction: column; align-items: center; justify-content: center; color: #999; font-size: 11px; background: #1a1a1a;">
                    <span style="font-size: 2em;">üé¨</span>
                </div>
                <div style="position: absolute; bottom: 4px; right: 4px; background: rgba(0,0,0,0.7); color: #fff; padding: 2px 6px; border-radius: 3px; font-size: 10px;">‚ñ∂Ô∏è</div>
            </div>
            <div style="padding: 0 4px;">
                <div style="color: #e0e0e0; font-weight: 500; font-size: 13px; word-break: break-word; text-align: center; margin-bottom: 4px;">${file.name}</div>
                <div style="color: #666; font-size: 11px; text-align: center;">(${file.size_mb} MB)</div>
            </div>
        </div>
    `;
}

// Toggle video folder expand/collapse
function toggleVideoFolder(folderId) {
    const content = document.getElementById(folderId);
    if (content) {
        const isVisible = content.style.display !== 'none';
        content.style.display = isVisible ? 'none' : 'block';
        
        // Update icon - find the header that contains this folder's ID
        const folderDiv = content.parentElement;
        if (folderDiv && folderDiv.classList.contains('video-folder')) {
            const header = folderDiv.querySelector('.folder-header');
            if (header) {
                const icon = header.querySelector('.folder-icon');
                if (icon) {
                    icon.textContent = isVisible ? '‚ñ∂' : '‚ñº';
                }
            }
        }
    }
}

// Make toggleVideoFolder available globally
window.toggleVideoFolder = toggleVideoFolder;

// Helper function to check and update video selection state on mouseout
window.checkVideoSelectionState = function(element, filePath) {
    const bulkMode = window.appData.bulkMode || false;
    const currentVideoPath = window.appData.videoPath;
    
    let isSelected = false;
    if (bulkMode) {
        const selectedVideos = window.appData.selectedVideos || [];
        isSelected = selectedVideos.some(v => v.path === filePath);
    } else {
        isSelected = (currentVideoPath === filePath);
    }
    
    if (isSelected) {
        element.style.background = '#2a3a4a';
        element.style.borderColor = '#667eea';
        element.style.borderWidth = '3px';
        element.style.boxShadow = '0 0 0 2px rgba(102, 126, 234, 0.3)';
        element.classList.add('selected');
    } else {
        element.style.background = '#1e1e1e';
        element.style.borderColor = '#555';
        element.style.borderWidth = '2px';
        element.style.boxShadow = 'none';
        element.classList.remove('selected');
    }
};

// Handle video click (single or bulk mode)
window.handleVideoClick = function(filePath, fileName) {
    if (window.appData.bulkMode) {
        // Bulk mode: toggle selection
        toggleVideoSelection(filePath, fileName);
    } else {
        // Single mode: immediate selection (existing behavior)
        selectSingleVideo(filePath, fileName);
    }
};

// Toggle video selection in bulk mode
window.toggleVideoSelection = function(filePath, fileName) {
    // Ensure selectedVideos is initialized
    if (!window.appData.selectedVideos) {
        window.appData.selectedVideos = [];
    }
    
    const index = window.appData.selectedVideos.findIndex(v => v.path === filePath);
    
    if (index >= 0) {
        // Deselect
        window.appData.selectedVideos.splice(index, 1);
        debug(`Deselected: ${fileName}`, 'info');
    } else {
        // Select (limit to 20 videos)
        if (window.appData.selectedVideos.length >= 20) {
            alert('Maximum 20 videos can be selected at once.');
            return;
        }
        
        window.appData.selectedVideos.push({
            path: filePath,
            name: fileName,
            info: null // Will be loaded later
        });
        debug(`Selected: ${fileName} (${window.appData.selectedVideos.length} selected)`, 'info');
    }
    
    // Re-render to update UI
    if (window.appData.availableFiles) {
        renderVideoList(window.appData.availableFiles);
    }
    
    updateSelectionUI();
};

// Select single video (existing behavior)
window.selectSingleVideo = function(filePath, fileName) {
    debug(`Selecting file: ${fileName}`, 'info');
    
    fetch('/v2p-formatter/select_file', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ file_path: filePath })
    })
    .then(r => r.json())
    .then(data => {
        if (data.success) {
            // PRESERVE existing time points before doing anything else
            const existingTimes = window.appData.selectedTimes || [];
            console.log('üìπ DEBUG selectSingleVideo: Preserving time points:', existingTimes);
            
            window.appData.videoPath = data.filepath;
            window.appData.videoInfo = data;
            
            // Re-render video list to update highlighting
            if (window.appData.availableFiles && window.appData.availableFiles.length > 0) {
                renderVideoList(window.appData.availableFiles);
            }
            
            const video = document.getElementById('videoPlayer');
            if (video) {
                video.src = `/v2p-formatter/video_file?path=${encodeURIComponent(filePath)}`;
            }
            
            const infoDiv = document.getElementById('videoInfo');
            if (infoDiv) {
                infoDiv.innerHTML = `
                    <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); gap: 15px; margin-top: 15px;">
                        <div><strong>Duration:</strong> ${data.duration.toFixed(2)}s</div>
                        <div><strong>Resolution:</strong> ${data.width}x${data.height}</div>
                        <div><strong>FPS:</strong> ${data.fps.toFixed(2)}</div>
                        <div><strong>File:</strong> ${data.filename}</div>
                    </div>
                `;
            }
            
            document.getElementById('timeSection').style.display = 'block';
            document.getElementById('outputSettingsSection').style.display = 'block';
            document.getElementById('processingSection').style.display = 'block';
            
            // RESTORE time points (don't let initTimeSelector or anything else clear them)
            window.appData.selectedTimes = existingTimes;
            console.log('üìπ DEBUG: Restored time points:', window.appData.selectedTimes);
            
            // Initialize time selector (will preserve existing times)
            setTimeout(() => {
                initTimeSelector();
                updateTimeDisplay(); // Ensure UI shows preserved times
                console.log('üìπ DEBUG: After initTimeSelector, selectedTimes =', window.appData.selectedTimes);
            }, 500);
            
            debug(`File loaded successfully. Time points preserved: ${existingTimes.length}`, 'success');
        } else {
            alert('Error: ' + (data.error || 'Failed to load file'));
            debug('Error loading file: ' + (data.error || 'Unknown'), 'error');
        }
    })
    .catch(err => {
        alert('Error: ' + err.message);
        debug('Error: ' + err.message, 'error');
    });
};

// Update selection UI (count badge, select all checkbox, batch indicators)
function updateSelectionUI() {
    if (!window.appData.selectedVideos) {
        window.appData.selectedVideos = [];
    }
    const count = window.appData.selectedVideos.length;
    const countBadge = document.getElementById('selectionCountBadge');
    const countText = document.getElementById('selectionCount');
    const selectAllContainer = document.getElementById('selectAllContainer');
    const selectAllCheckbox = document.getElementById('selectAllCheckbox');
    
    if (window.appData.bulkMode) {
        // Show selection count
        if (countBadge) {
            countBadge.style.display = 'block';
            if (countText) countText.textContent = count;
        }
        
        // Show select all container
        if (selectAllContainer) {
            selectAllContainer.style.display = 'flex';
        }
        
        // Update select all checkbox
        if (selectAllCheckbox && window.appData.availableFiles) {
            const allSelected = window.appData.availableFiles.length > 0 && 
                               window.appData.selectedVideos.length === window.appData.availableFiles.length &&
                               window.appData.selectedVideos.length <= 20;
            selectAllCheckbox.checked = allSelected;
            selectAllCheckbox.indeterminate = count > 0 && count < Math.min(window.appData.availableFiles.length, 20);
        }
        
        // Update batch mode indicators
        const batchIndicator = document.getElementById('batchModeIndicator');
        const batchSettingsIndicator = document.getElementById('batchSettingsIndicator');
        if (batchIndicator && count > 0) {
            batchIndicator.style.display = 'block';
            document.getElementById('batchModeInfo').textContent = `Time points will be applied to all ${count} selected video(s).`;
        }
        if (batchSettingsIndicator && count > 0) {
            batchSettingsIndicator.style.display = 'block';
            document.getElementById('batchSettingsInfo').textContent = `These settings will apply to all ${count} selected video(s).`;
        }
        
        // Show sections if videos are selected
        if (count > 0) {
            // PRESERVE existing time points BEFORE showing sections
            const existingTimes = window.appData.selectedTimes || [];
            
            document.getElementById('timeSection').style.display = 'block';
            document.getElementById('outputSettingsSection').style.display = 'block';
            document.getElementById('processingSection').style.display = 'block';
            
            // In bulk mode: Load video info IMMEDIATELY if not already loaded
            if (window.appData.bulkMode && window.appData.selectedVideos.length > 0) {
                const firstVideo = window.appData.selectedVideos[0];
                
                // Check if we already have video info
                if (firstVideo.info && firstVideo.info.duration) {
                    // Info already loaded - use it
                    window.appData.videoInfo = firstVideo.info;
                    window.appData.videoPath = firstVideo.path;
                    setupVideoPlayer(firstVideo);
                    window.appData.selectedTimes = existingTimes; // Preserve times
                    setTimeout(() => {
                        initTimeSelector();
                        updateTimeDisplay();
                    }, 100);
                } else if (window.appData.videoInfo && window.appData.videoInfo.duration) {
                    // Use existing videoInfo (might be from previous selection)
                    firstVideo.info = window.appData.videoInfo;
                    setupVideoPlayer(firstVideo);
                    window.appData.selectedTimes = existingTimes;
                    setTimeout(() => {
                        initTimeSelector();
                        updateTimeDisplay();
                    }, 100);
                } else {
                    // Need to load video info - show loading indicator
                    showVideoInfoLoading(true);
                    
                    fetch('/v2p-formatter/select_file', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ file_path: firstVideo.path })
                    })
                    .then(r => r.json())
                    .then(data => {
                        showVideoInfoLoading(false);
                        if (data.success) {
                            // Store video info in BOTH places (single source of truth + backup)
                            firstVideo.info = data;
                            window.appData.videoInfo = data;  // PRIMARY SOURCE
                            window.appData.videoPath = data.filepath;
                            
                            // Setup video player
                            setupVideoPlayer(firstVideo);
                            
                            // Preserve existing time points
                            window.appData.selectedTimes = existingTimes;
                            
                            // Initialize time selector
                            setTimeout(() => {
                                initTimeSelector();
                                updateTimeDisplay();
                                debug('Video info loaded. Ready for time point generation.', 'success');
                            }, 100);
                        } else {
                            showVideoInfoError('Failed to load video info: ' + (data.error || 'Unknown error'));
                        }
                    })
                    .catch(err => {
                        showVideoInfoLoading(false);
                        showVideoInfoError('Error loading video info: ' + err.message);
                    });
                }
            } else {
                // Not bulk mode - just preserve times
                window.appData.selectedTimes = existingTimes;
            }
        }
        
        // Update button labels
        updateExtractButtonLabel();
    } else {
        // Hide selection UI
        const batchIndicator = document.getElementById('batchModeIndicator');
        const batchSettingsIndicator = document.getElementById('batchSettingsIndicator');
        if (countBadge) countBadge.style.display = 'none';
        if (selectAllContainer) selectAllContainer.style.display = 'none';
        if (batchIndicator) batchIndicator.style.display = 'none';
        if (batchSettingsIndicator) batchSettingsIndicator.style.display = 'none';
        
        // Reset button labels
        updateExtractButtonLabel();
    }
}

// Helper function to setup video player
function setupVideoPlayer(video) {
    const videoElement = document.getElementById('videoPlayer');
    if (videoElement && video.path) {
        videoElement.src = `/v2p-formatter/video_file?path=${encodeURIComponent(video.path)}`;
    }
}

// Show/hide loading indicator for video info
function showVideoInfoLoading(show) {
    const timeSection = document.getElementById('timeSection');
    if (!timeSection) return;
    
    let loader = document.getElementById('videoInfoLoader');
    if (show) {
        if (!loader) {
            loader = document.createElement('div');
            loader.id = 'videoInfoLoader';
            loader.style.cssText = 'padding: 15px; margin: 15px 0; background: #2a3a4a; border-left: 4px solid #667eea; border-radius: 4px; color: #e0e0e0;';
            loader.innerHTML = '<strong>‚è≥ Loading video information...</strong><br><span style="color: #999; font-size: 14px;">Please wait while we prepare time point generation.</span>';
            const videoContainer = timeSection.querySelector('.video-container');
            if (videoContainer) {
                timeSection.insertBefore(loader, videoContainer);
            } else {
                timeSection.appendChild(loader);
            }
        }
        loader.style.display = 'block';
        // Disable auto-generate dropdown while loading
        const autoShotsSelect = document.getElementById('autoShotsSelect');
        if (autoShotsSelect) autoShotsSelect.disabled = true;
    } else {
        if (loader) loader.style.display = 'none';
        const autoShotsSelect = document.getElementById('autoShotsSelect');
        if (autoShotsSelect) autoShotsSelect.disabled = false;
    }
}

// Show error message for video info loading
function showVideoInfoError(message) {
    const timeSection = document.getElementById('timeSection');
    if (!timeSection) return;
    
    let errorDiv = document.getElementById('videoInfoError');
    if (!errorDiv) {
        errorDiv = document.createElement('div');
        errorDiv.id = 'videoInfoError';
        errorDiv.style.cssText = 'padding: 15px; margin: 15px 0; background: #3a2a2a; border-left: 4px solid #ff6b6b; border-radius: 4px; color: #e0e0e0;';
        const videoContainer = timeSection.querySelector('.video-container');
        if (videoContainer) {
            timeSection.insertBefore(errorDiv, videoContainer);
        } else {
            timeSection.appendChild(errorDiv);
        }
    }
    errorDiv.innerHTML = `<strong>‚ùå Error:</strong> ${message}<br><span style="color: #999; font-size: 14px;">You can still add time points manually.</span>`;
    errorDiv.style.display = 'block';
    
    // Hide after 5 seconds
    setTimeout(() => {
        errorDiv.style.display = 'none';
    }, 5000);
}

// Select/Deselect all videos
window.toggleSelectAll = function() {
    const checkbox = document.getElementById('selectAllCheckbox');
    if (!checkbox || !window.appData.availableFiles) return;
    
    const selectAll = checkbox.checked;
    
    if (selectAll) {
        // Select all (up to limit)
        window.appData.selectedVideos = [];
        const maxVideos = Math.min(20, window.appData.availableFiles.length);
        
        for (let i = 0; i < maxVideos; i++) {
            const file = window.appData.availableFiles[i];
            window.appData.selectedVideos.push({
                path: file.path,
                name: file.name,
                info: null
            });
        }
        
        if (window.appData.availableFiles.length > 20) {
            alert('Only first 20 videos selected (maximum batch size).');
        }
        
        debug(`Selected all ${window.appData.selectedVideos.length} videos`, 'info');
    } else {
        // Deselect all
        window.appData.selectedVideos = [];
        debug('Deselected all videos', 'info');
    }
    
    // Re-render
    renderVideoList(window.appData.availableFiles);
    updateSelectionUI();
};

// Toggle bulk mode
window.toggleBulkMode = function() {
    const checkbox = document.getElementById('bulkModeToggle');
    if (!checkbox) return;
    
    window.appData.bulkMode = checkbox.checked;
    
    if (window.appData.bulkMode) {
        // Entering bulk mode - clear single video selection (but keep time points and videoInfo if available)
        window.appData.videoPath = null;
        // DON'T clear videoInfo - might be needed for auto-generate time points
        // window.appData.videoInfo = null;
        // DON'T clear selectedTimes - user might have already set them up
        // window.appData.selectedTimes = [];
        window.appData.extractedImages = [];
        
        // Hide single video sections
        document.getElementById('timeSection').style.display = 'none';
        document.getElementById('outputSettingsSection').style.display = 'none';
        document.getElementById('processingSection').style.display = 'none';
        
        // Show batch mode indicators when sections are shown later
        const batchIndicator = document.getElementById('batchModeIndicator');
        const batchSettingsIndicator = document.getElementById('batchSettingsIndicator');
        if (batchIndicator) {
            const count = window.appData.selectedVideos.length;
            if (count > 0) {
                document.getElementById('batchModeInfo').textContent = `Time points will be applied to all ${count} selected video(s).`;
            } else {
                document.getElementById('batchModeInfo').textContent = 'Time points will be applied to all selected videos.';
            }
        }
        if (batchSettingsIndicator) {
            const count = window.appData.selectedVideos.length;
            if (count > 0) {
                document.getElementById('batchSettingsInfo').textContent = `These settings will apply to all ${count} selected video(s).`;
            } else {
                document.getElementById('batchSettingsInfo').textContent = 'These settings will apply to all selected videos.';
            }
        }
        
        debug('Entered bulk selection mode', 'info');
    } else {
        // Exiting bulk mode - clear bulk selections
        window.appData.selectedVideos = [];
        
        // Hide batch mode indicators
        const batchIndicator = document.getElementById('batchModeIndicator');
        const batchSettingsIndicator = document.getElementById('batchSettingsIndicator');
        if (batchIndicator) batchIndicator.style.display = 'none';
        if (batchSettingsIndicator) batchSettingsIndicator.style.display = 'none';
        
        debug('Exited bulk selection mode', 'info');
    }
    
    // Re-render video list
    if (window.appData.availableFiles) {
        renderVideoList(window.appData.availableFiles);
    }
    
    updateSelectionUI();
};

// Validate bulk time points before processing
async function validateBulkTimePoints(videoPaths, timePoints) {
    try {
        const response = await fetch('/v2p-formatter/validate_batch_time_points', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
                video_paths: videoPaths,
                time_points: timePoints
            })
        });
        
        const data = await response.json();
        if (!data.success) {
            throw new Error(data.error || 'Validation failed');
        }
        
        // Check for warnings
        if (data.has_warnings) {
            let warningMessage = 'Some videos have time points that exceed their duration:\n\n';
            data.results.forEach(result => {
                if (result.warnings && result.warnings.length > 0) {
                    warningMessage += `‚Ä¢ ${result.filename}: ${result.warnings[0].message}\n`;
                }
            });
            warningMessage += '\nInvalid time points will be clamped to video duration. Continue?';
            
            if (!confirm(warningMessage)) {
                throw new Error('User cancelled due to warnings');
            }
        }
        
        return data;
    } catch (err) {
        throw err;
    }
}

// Start bulk extraction process
async function startBulkExtraction(selectedVideos, timePoints) {
    const quality = parseInt(document.getElementById('qualitySlider').value) || 95;
    const resolution = document.getElementById('resolutionSelect').value || 'original';
    
    // Initialize batch results
    window.appData.batchResults = selectedVideos.map((video, index) => ({
        index: index,
        video: video,
        status: 'pending',
        extractedImages: [],
        error: null
    }));
    
    // Show batch progress container
    const batchContainer = document.getElementById('batchProgressContainer');
    const batchFill = document.getElementById('batchProgressFill');
    const batchText = document.getElementById('batchProgressText');
    const batchStatusList = document.getElementById('batchVideoStatusList');
    
    batchContainer.style.display = 'block';
    document.getElementById('progressContainer').style.display = 'none';
    batchFill.style.width = '0%';
    batchText.textContent = `Processing video 1 of ${selectedVideos.length}...`;
    
    // Clear status list
    batchStatusList.innerHTML = '';
    selectedVideos.forEach((video, index) => {
        const statusItem = document.createElement('div');
        statusItem.id = `batch-status-${index}`;
        statusItem.style.cssText = 'padding: 10px; margin: 5px 0; background: #2a2a2a; border-radius: 4px; border-left: 4px solid #666; display: flex; align-items: center; justify-content: space-between;';
        statusItem.innerHTML = `
            <div>
                <strong style="color: #e0e0e0;">${video.name}</strong>
                <div style="color: #999; font-size: 12px; margin-top: 2px;">‚è∏Ô∏è Pending</div>
            </div>
        `;
        batchStatusList.appendChild(statusItem);
    });
    
    // Process videos sequentially
    let completed = 0;
    
    for (let i = 0; i < selectedVideos.length; i++) {
        const video = selectedVideos[i];
        const statusItem = document.getElementById(`batch-status-${i}`);
        
        // Update current video status
        batchText.textContent = `Processing video ${i + 1} of ${selectedVideos.length}: ${video.name}`;
        window.appData.currentBatchIndex = i;
        
        // Update status item to processing
        statusItem.style.borderLeftColor = '#667eea';
        statusItem.innerHTML = `
            <div>
                <strong style="color: #e0e0e0;">${video.name}</strong>
                <div style="color: #667eea; font-size: 12px; margin-top: 2px;">‚è≥ Processing...</div>
            </div>
        `;
        
        try {
            // Extract frames
            const response = await fetch('/v2p-formatter/extract_frames', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    video_path: video.path,
                    time_points: timePoints.map(t => parseFloat(t)),
                    quality: quality,
                    resolution: resolution
                })
            });
            
            const data = await response.json();
            
            if (data.success) {
                // Success
                window.appData.batchResults[i].status = 'completed';
                window.appData.batchResults[i].extractedImages = data.images || [];
                
                statusItem.style.borderLeftColor = '#4ade80';
                statusItem.innerHTML = `
                    <div>
                        <strong style="color: #e0e0e0;">${video.name}</strong>
                        <div style="color: #4ade80; font-size: 12px; margin-top: 2px;">‚úÖ Completed - ${data.count} frames</div>
                    </div>
                `;
                
                debug(`Extracted frames for ${video.name}: ${data.count} frames`, 'success');
                
                // Automatically generate PDF after frame extraction
                try {
                    const layout = document.getElementById('layoutSelect')?.value || 'grid';
                    const imagesPerPage = parseInt(document.getElementById('imagesPerPage')?.value || 4);
                    
                    statusItem.innerHTML = `
                        <div>
                            <strong style="color: #e0e0e0;">${video.name}</strong>
                            <div style="color: #667eea; font-size: 12px; margin-top: 2px;">‚è≥ Generating PDF...</div>
                        </div>
                    `;
                    
                    const pdfResponse = await fetch('/v2p-formatter/generate_pdf', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            video_path: video.path,
                            image_paths: data.images || [],
                            layout: layout,
                            images_per_page: imagesPerPage
                        })
                    });
                    
                    const pdfData = await pdfResponse.json();
                    if (pdfData.success) {
                        window.appData.batchResults[i].pdfResult = pdfData;
                        statusItem.innerHTML = `
                            <div>
                                <strong style="color: #e0e0e0;">${video.name}</strong>
                                <div style="color: #4ade80; font-size: 12px; margin-top: 2px;">‚úÖ PDF Generated - ${data.count} frames</div>
                            </div>
                        `;
                        debug(`PDF generated for ${video.name}: ${pdfData.filename}`, 'success');
                    } else {
                        window.appData.batchResults[i].pdfError = pdfData.error || 'Unknown error';
                        statusItem.innerHTML = `
                            <div>
                                <strong style="color: #e0e0e0;">${video.name}</strong>
                                <div style="color: #ff6b6b; font-size: 12px; margin-top: 2px;">‚ö†Ô∏è Frames extracted, PDF failed</div>
                            </div>
                        `;
                        debug(`PDF generation failed for ${video.name}: ${pdfData.error}`, 'error');
                    }
                } catch (pdfErr) {
                    window.appData.batchResults[i].pdfError = pdfErr.message;
                    statusItem.innerHTML = `
                        <div>
                            <strong style="color: #e0e0e0;">${video.name}</strong>
                            <div style="color: #ff6b6b; font-size: 12px; margin-top: 2px;">‚ö†Ô∏è Frames extracted, PDF error</div>
                        </div>
                    `;
                    debug(`PDF generation error for ${video.name}: ${pdfErr.message}`, 'error');
                }
            } else {
                // Error
                window.appData.batchResults[i].status = 'error';
                window.appData.batchResults[i].error = data.error || 'Unknown error';
                
                statusItem.style.borderLeftColor = '#ff6b6b';
                statusItem.innerHTML = `
                    <div>
                        <strong style="color: #e0e0e0;">${video.name}</strong>
                        <div style="color: #ff6b6b; font-size: 12px; margin-top: 2px;">‚ùå Error: ${data.error || 'Unknown'}</div>
                    </div>
                `;
                
                debug(`Error extracting frames for ${video.name}: ${data.error}`, 'error');
            }
        } catch (err) {
            // Network or other error
            window.appData.batchResults[i].status = 'error';
            window.appData.batchResults[i].error = err.message;
            
            statusItem.style.borderLeftColor = '#ff6b6b';
            statusItem.innerHTML = `
                <div>
                    <strong style="color: #e0e0e0;">${video.name}</strong>
                    <div style="color: #ff6b6b; font-size: 12px; margin-top: 2px;">‚ùå Error: ${err.message}</div>
                </div>
            `;
            
            debug(`Error extracting frames for ${video.name}: ${err.message}`, 'error');
        }
        
        // Update progress
        completed++;
        const progressPercent = Math.round((completed / selectedVideos.length) * 100);
        batchFill.style.width = progressPercent + '%';
    }
    
    // All done
    batchText.textContent = `Batch extraction and PDF generation complete! ${completed} of ${selectedVideos.length} videos processed.`;
    
    // Show generate button if any videos succeeded (for DOCX generation if needed)
    const successfulVideos = window.appData.batchResults.filter(r => r.status === 'completed');
    if (successfulVideos.length > 0) {
        document.getElementById('generateOutputBtn').style.display = 'inline-block';
        updateGenerateButtonLabel();
    }
    
    // Show summary first
    showBulkExtractionResults();
    
    // Then show PDF results (this will append or replace the results div)
    const pdfResults = window.appData.batchResults
        .filter(r => r.status === 'completed' && r.pdfResult)
        .map(r => r.pdfResult);
    
    // Show PDF results if any were generated (after bulk summary)
    if (pdfResults.length > 0) {
        // Small delay to ensure bulk summary is shown first
        setTimeout(() => {
            showPDFResults({ results: pdfResults });
        }, 100);
    }
}

// Show bulk extraction results summary
function showBulkExtractionResults() {
    if (!window.appData.batchResults) {
        window.appData.batchResults = [];
    }
    const results = window.appData.batchResults;
    const successful = results.filter(r => r.status === 'completed').length;
    const failed = results.filter(r => r.status === 'error').length;
    
    let html = '<div style="padding: 15px; background: #1e3a1e; border: 1px solid #2d5a2d; border-radius: 6px; margin-top: 15px; color: #e0e0e0;">';
    html += `<strong>‚úÖ Batch Extraction Complete!</strong><br><br>`;
    html += `Successfully processed: ${successful} of ${results.length} videos<br>`;
    
    if (failed > 0) {
        html += `<span style="color: #ff6b6b;">Failed: ${failed} videos</span><br>`;
    }
    
    html += '</div>';
    
    document.getElementById('results').innerHTML = html;
}

// Update button labels based on mode
function updateExtractButtonLabel() {
    const btn = document.getElementById('extractFramesBtn');
    if (!btn) return;
    
    if (window.appData.bulkMode && window.appData.selectedVideos.length > 0) {
        btn.textContent = `Extract Frames for All ${window.appData.selectedVideos.length} Videos`;
    } else {
        btn.textContent = 'Extract Frames';
    }
}

function updateGenerateButtonLabel() {
    const btn = document.getElementById('generateOutputBtn');
    if (!btn) return;
    
    if (window.appData.bulkMode) {
        const successful = window.appData.batchResults ? 
            window.appData.batchResults.filter(r => r.status === 'completed').length : 0;
        if (successful > 0) {
            btn.textContent = `Generate Documents for All ${successful} Videos`;
        }
    } else {
        btn.textContent = 'Generate PDF & DOCX';
    }
}

// Initialize bulk mode controls
document.addEventListener('DOMContentLoaded', function() {
    const bulkModeToggle = document.getElementById('bulkModeToggle');
    const selectAllCheckbox = document.getElementById('selectAllCheckbox');
    
    if (bulkModeToggle) {
        bulkModeToggle.addEventListener('change', toggleBulkMode);
    }
    
    if (selectAllCheckbox) {
        selectAllCheckbox.addEventListener('change', toggleSelectAll);
    }
    
    // Initialize UI state
    updateSelectionUI();
});

// Time selector - WITH PREVIEW THUMBNAILS AND AUTO-GENERATION
function initTimeSelector() {
    debug('Initializing time selector...', 'info');
    
    const addBtn = document.getElementById('addCurrentTimeBtn');
    const clearBtn = document.getElementById('clearAllTimesBtn');
    const autoShotsSelect = document.getElementById('autoShotsSelect');
    const customShotsInput = document.getElementById('customShotsInput');
    const applyAutoShotsBtn = document.getElementById('applyAutoShotsBtn');
    
    if (!addBtn || !clearBtn) {
        debug('Time selector buttons not found', 'error');
        return;
    }
    
    // Remove old handlers
    const newAdd = addBtn.cloneNode(true);
    addBtn.parentNode.replaceChild(newAdd, addBtn);
    const newClear = clearBtn.cloneNode(true);
    clearBtn.parentNode.replaceChild(newClear, clearBtn);
    
    // Get fresh references
    const freshAdd = document.getElementById('addCurrentTimeBtn');
    const freshClear = document.getElementById('clearAllTimesBtn');
    
    freshAdd.onclick = function() {
        // Check if in bulk mode
        if (window.appData.bulkMode) {
            // In bulk mode, show input dialog for manual time entry
            const timeInput = prompt('Enter time point in seconds (e.g., 10.5):');
            if (timeInput === null) return; // User cancelled
            
            const time = parseFloat(timeInput);
            if (isNaN(time) || time < 0) {
                alert('Invalid time. Please enter a number >= 0.');
                return;
            }
            
            if (!window.appData.selectedTimes) {
                window.appData.selectedTimes = [];
            }
            
            if (window.appData.selectedTimes.includes(time)) {
                debug(`Time ${time.toFixed(2)}s already added`, 'info');
                return;
            }
            
            window.appData.selectedTimes.push(time);
            window.appData.selectedTimes.sort((a, b) => a - b);
            console.log('DEBUG: After adding time, selectedTimes =', window.appData.selectedTimes);
            updateTimeDisplay();
            debug(`Added time: ${time.toFixed(2)}s. Total: ${window.appData.selectedTimes.length} time points`, 'success');
        } else {
            // Single mode: use video player
        const video = document.getElementById('videoPlayer');
        if (!video) {
            alert('Video not found');
            return;
        }
        
        const time = Math.round(video.currentTime * 100) / 100;
        if (isNaN(time) || time < 0) {
            alert('Video not ready');
            return;
        }
            
            if (!window.appData.selectedTimes) {
                window.appData.selectedTimes = [];
        }
        
        if (window.appData.selectedTimes.includes(time)) {
            debug(`Time ${time.toFixed(2)}s already added`, 'info');
            return;
        }
        
        window.appData.selectedTimes.push(time);
        window.appData.selectedTimes.sort((a, b) => a - b);
            console.log('‚úÖ DEBUG: Added time point (single mode). selectedTimes now =', window.appData.selectedTimes, 'length =', window.appData.selectedTimes.length);
        
        // Add thumbnail preview
        addTimePointWithThumbnail(time);
            debug(`Added time: ${time.toFixed(2)}s. Total: ${window.appData.selectedTimes.length} time points`, 'success');
        }
    };
    
    freshClear.onclick = function() {
        if (!window.appData.selectedTimes) {
        window.appData.selectedTimes = [];
        }
        window.appData.selectedTimes = [];
        if (!window.appData.timeThumbnails) {
        window.appData.timeThumbnails = {};
        } else {
            window.appData.timeThumbnails = {};
        }
        updateTimeDisplay();
        debug('Cleared all times', 'info');
    };
    
    // Auto-shots selector
    if (autoShotsSelect) {
        autoShotsSelect.onchange = function() {
            const value = this.value;
            if (value === 'custom') {
                customShotsInput.style.display = 'inline-block';
                applyAutoShotsBtn.style.display = 'inline-block';
            } else if (value === '') {
                customShotsInput.style.display = 'none';
                applyAutoShotsBtn.style.display = 'none';
            } else {
                customShotsInput.style.display = 'none';
                applyAutoShotsBtn.style.display = 'none';
                // Auto-apply: generateAutoTimePoints will handle video info loading if needed
                const numShots = parseInt(value);
                generateAutoTimePoints(numShots);
            }
        };
    }
    
    // Apply custom shots button
    if (applyAutoShotsBtn) {
        applyAutoShotsBtn.onclick = function() {
            const numShots = parseInt(customShotsInput.value);
            if (isNaN(numShots) || numShots < 1 || numShots > 100) {
                alert('Please enter a number between 1 and 100');
                return;
            }
            generateAutoTimePoints(numShots);
        };
    }
    
    // Initialize thumbnails object
    if (!window.appData.timeThumbnails) {
        window.appData.timeThumbnails = {};
    }
    
    updateTimeDisplay();
    debug('Time selector ready', 'success');
}

// Generate evenly spaced time points
function generateAutoTimePoints(numShots) {
    // STATE CHECK: Ensure we have video info
    let duration = null;
    
    if (window.appData.bulkMode) {
        // BULK MODE: Use window.appData.videoInfo as primary source
        if (window.appData.videoInfo && window.appData.videoInfo.duration) {
            duration = window.appData.videoInfo.duration;
            debug(`Generating ${numShots} time points (video duration: ${duration.toFixed(2)}s)`, 'info');
            generateAutoTimePointsWithDuration(numShots, duration);
        } else {
            // Video info not loaded yet - check if it's being loaded
            const selectedVideos = window.appData.selectedVideos || [];
            if (selectedVideos.length === 0) {
                alert('Please select at least one video first!');
                return;
            }
            
            // Try to load video info now
            const firstVideo = selectedVideos[0];
            showVideoInfoLoading(true);
            
            fetch('/v2p-formatter/select_file', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ file_path: firstVideo.path })
            })
            .then(r => r.json())
            .then(data => {
                showVideoInfoLoading(false);
                if (data.success) {
                    firstVideo.info = data;
                    window.appData.videoInfo = data;
                    window.appData.videoPath = data.filepath;
                    debug(`Generating ${numShots} time points (video duration: ${data.duration.toFixed(2)}s)`, 'info');
                    generateAutoTimePointsWithDuration(numShots, data.duration);
                } else {
                    showVideoInfoError('Failed to load video info. Please try again.');
                    promptForDurationAndGenerate(numShots);
                }
            })
            .catch(err => {
                showVideoInfoLoading(false);
                showVideoInfoError('Error loading video info: ' + err.message);
                promptForDurationAndGenerate(numShots);
            });
            return; // Will continue after async fetch
        }
    } else {
        // SINGLE MODE: Use existing video info
        const videoInfo = window.appData.videoInfo || (typeof appState !== 'undefined' ? appState.videoInfo : null);
    
    if (!videoInfo || !videoInfo.duration) {
        alert('Video info not available. Please wait for video to load.');
        return;
    }
    
        duration = videoInfo.duration;
        debug(`Generating ${numShots} time points (video duration: ${duration.toFixed(2)}s)`, 'info');
        generateAutoTimePointsWithDuration(numShots, duration);
    }
}

// Helper function to generate time points with a known duration
function generateAutoTimePointsWithDuration(numShots, duration) {
    // Validate input
    if (!duration || duration <= 0 || isNaN(duration)) {
        alert('Invalid video duration. Cannot generate time points.');
        return;
    }
    
    if (!numShots || numShots < 1 || isNaN(numShots)) {
        alert('Invalid number of shots. Please select a valid number.');
        return;
    }
    
    const maxTime = Math.max(0, duration - 0.01); // Ensure we're always slightly before the end
    
    // Initialize arrays if needed
    if (!window.appData.selectedTimes) {
    window.appData.selectedTimes = [];
    }
    if (!window.appData.timeThumbnails) {
        window.appData.timeThumbnails = {};
    }
    
    // Clear existing times (user explicitly requested new generation)
    window.appData.selectedTimes = [];
    window.appData.timeThumbnails = {};
    
    // Generate evenly spaced time points
    const times = [];
    if (numShots === 1) {
        // Single shot at middle
        const time = Math.min(duration / 2, maxTime);
        times.push(Math.round(time * 100) / 100);
    } else {
        // Evenly spaced from start to (duration - small buffer)
        const startTime = 0;
        const endTime = maxTime;
        const interval = (endTime - startTime) / (numShots - 1);
        
        for (let i = 0; i < numShots; i++) {
            let time = startTime + (i * interval);
            time = Math.max(0, Math.min(time, maxTime));
            times.push(Math.round(time * 100) / 100);
        }
    }
    
    // Remove duplicates and sort
    const uniqueTimes = [...new Set(times)].sort((a, b) => a - b);
    
    // Validate generation result
    if (uniqueTimes.length === 0) {
        alert('Failed to generate time points. Please try again.');
        return;
    }
    
    // Store time points
    window.appData.selectedTimes = uniqueTimes;
    
    // Update UI
    updateTimeDisplay();
    
    // Load thumbnails for all time points (if we have a video path)
    const videoPath = window.appData.videoPath || 
                     (window.appData.selectedVideos && window.appData.selectedVideos.length > 0 ? 
                      window.appData.selectedVideos[0].path : null);
    
    if (videoPath) {
        // Temporarily set videoPath for thumbnail loading if needed
        if (!window.appData.videoPath) {
            window.appData.videoPath = videoPath;
        }
        
    uniqueTimes.forEach((time, index) => {
        setTimeout(() => {
            addTimePointWithThumbnail(time);
        }, index * 200); // Stagger thumbnail loading
    });
    }
    
    debug(`‚úÖ Generated ${uniqueTimes.length} time point(s) (${uniqueTimes[0].toFixed(2)}s${uniqueTimes.length > 1 ? ' to ' + uniqueTimes[uniqueTimes.length-1].toFixed(2) + 's' : ''})`, 'success');
}

function addTimePointWithThumbnail(time) {
    if (!window.appData.videoPath) {
        updateTimeDisplay();
        return;
    }
    
    // Get preview thumbnail from backend
    fetch('/v2p-formatter/preview_frame', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
            video_path: window.appData.videoPath,
            time_point: time
        })
    })
    .then(response => {
        if (!response.ok) {
            throw new Error('Failed to get preview');
        }
        return response.blob();
    })
    .then(blob => {
        const url = URL.createObjectURL(blob);
        window.appData.timeThumbnails[time] = url;
        updateTimeDisplay();
        debug(`Thumbnail loaded for ${time.toFixed(2)}s`, 'success');
    })
    .catch(err => {
        debug(`Could not load thumbnail for ${time.toFixed(2)}s: ${err.message}`, 'warning');
        // Still show the time point without thumbnail
        updateTimeDisplay();
    });
}

function updateTimeDisplay() {
    const container = document.getElementById('timePointsList');
    if (!container) return;
    
    if (!window.appData.selectedTimes) {
        window.appData.selectedTimes = [];
    }
    const times = window.appData.selectedTimes;
    
    if (times.length === 0) {
        const helpText = window.appData.bulkMode ? 
            'No time points. Click "+ Add Current Time" to add manually, or use auto-generate.' :
            'No time points. Click "+ Add Current Time" to add.';
        container.innerHTML = `<p style="color: #999; font-style: italic; padding: 10px;">${helpText}</p>`;
        return;
    }
    
    let html = '<div style="display: grid; grid-template-columns: repeat(auto-fill, minmax(150px, 1fr)); gap: 15px;">';
    
    times.forEach(time => {
        const thumbnail = window.appData.timeThumbnails && window.appData.timeThumbnails[time];
        const timeStr = time.toFixed(2);
        
        html += `<div onclick="removeTime(${time})" style="
            position: relative;
            cursor: pointer;
            border: 2px solid #667eea;
            border-radius: 8px;
            overflow: hidden;
            background: #2a2a2a;
            transition: all 0.2s;
            box-shadow: 0 2px 4px rgba(0,0,0,0.3);
        " onmouseover="this.style.borderColor='#5568d3'; this.style.transform='scale(1.05)'; this.style.boxShadow='0 4px 8px rgba(0,0,0,0.4)'" 
           onmouseout="this.style.borderColor='#667eea'; this.style.transform='scale(1)'; this.style.boxShadow='0 2px 4px rgba(0,0,0,0.3)'"
           title="Click to remove">
            ${thumbnail ? 
                `<img src="${thumbnail}" style="width: 100%; height: 100px; object-fit: cover; display: block;" alt="Frame at ${timeStr}s">` :
                `<div style="width: 100%; height: 100px; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); display: flex; align-items: center; justify-content: center; color: white; font-size: 24px;">‚è±Ô∏è</div>`
            }
            <div style="padding: 8px; text-align: center; background: #1e1e1e; border-top: 1px solid #555;">
                <strong style="color: #e0e0e0; font-size: 14px;">${timeStr}s</strong>
                <div style="color: #999; font-size: 11px; margin-top: 2px;">Click to remove</div>
            </div>
            <div style="position: absolute; top: 5px; right: 5px; background: rgba(0,0,0,0.6); color: white; border-radius: 50%; width: 24px; height: 24px; display: flex; align-items: center; justify-content: center; font-size: 16px; font-weight: bold;">√ó</div>
        </div>`;
    });
    
    html += '</div>';
    container.innerHTML = html;
}

window.removeTime = function(time) {
    if (!window.appData.selectedTimes) {
        window.appData.selectedTimes = [];
    }
    window.appData.selectedTimes = window.appData.selectedTimes.filter(t => t !== time);
    // Clean up thumbnail URL
    if (window.appData.timeThumbnails && window.appData.timeThumbnails[time]) {
        URL.revokeObjectURL(window.appData.timeThumbnails[time]);
        delete window.appData.timeThumbnails[time];
    }
    updateTimeDisplay();
    debug(`Removed time: ${time.toFixed(2)}s`, 'info');
};

// Quality slider
document.addEventListener('DOMContentLoaded', function() {
    const slider = document.getElementById('qualitySlider');
    const value = document.getElementById('qualityValue');
    if (slider && value) {
        slider.oninput = function() {
            value.textContent = this.value;
        };
    }
});

// Extract frames
(function() {
    function initExtractBtn() {
        const btn = document.getElementById('extractFramesBtn');
        if (!btn) return;
        
        const newBtn = btn.cloneNode(true);
        btn.parentNode.replaceChild(newBtn, btn);
        const freshBtn = document.getElementById('extractFramesBtn');
        
        freshBtn.onclick = function() {
            // Check if bulk mode
            if (window.appData.bulkMode) {
                processBulkExtraction();
            } else {
                processSingleExtraction();
            }
        };
        
        function processSingleExtraction() {
            const times = window.appData.selectedTimes;
            if (!times || times.length === 0) {
                alert('Please add at least one time point first!');
                debug('No time points selected', 'error');
                return;
            }
            
            if (!window.appData.videoPath) {
                alert('Please select a video first!');
                return;
            }
            
            debug(`Extracting frames at times: ${times.join(', ')}`, 'info');
            
            const quality = parseInt(document.getElementById('qualitySlider').value) || 95;
            const resolution = document.getElementById('resolutionSelect').value || 'original';
            
            document.getElementById('progressContainer').style.display = 'block';
            document.getElementById('progressFill').style.width = '0%';
            document.getElementById('progressText').textContent = 'Extracting frames...';
            
            fetch('/v2p-formatter/extract_frames', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    video_path: window.appData.videoPath,
                    time_points: times.map(t => parseFloat(t)),
                    quality: quality,
                    resolution: resolution
                })
            })
            .then(r => r.json())
            .then(data => {
                if (data.success) {
                    window.appData.extractedImages = data.images || [];
                    document.getElementById('progressFill').style.width = '100%';
                    document.getElementById('progressText').textContent = `Extracted ${data.count} frames!`;
                    
                    // Automatically generate PDF after frame extraction
                    setTimeout(() => {
                        document.getElementById('progressContainer').style.display = 'none';
                        generatePDFAuto();
                    }, 1000);
                } else {
                    document.getElementById('progressContainer').style.display = 'none';
                    alert('Error: ' + (data.error || 'Failed to extract frames'));
                    debug('Extract error: ' + (data.error || 'Unknown'), 'error');
                }
            })
            .catch(err => {
                document.getElementById('progressContainer').style.display = 'none';
                alert('Error: ' + err.message);
                debug('Extract error: ' + err.message, 'error');
            });
        }
        
        function processBulkExtraction() {
            // Ensure selectedVideos is initialized
            if (!window.appData.selectedVideos) {
                window.appData.selectedVideos = [];
            }
            
            const selectedVideos = window.appData.selectedVideos;
            if (!selectedVideos || selectedVideos.length === 0) {
                alert('Please select at least one video in bulk mode!');
                return;
            }
            
            // Ensure selectedTimes is initialized
            if (!window.appData.selectedTimes) {
                window.appData.selectedTimes = [];
            }
            
            const times = window.appData.selectedTimes;
            console.log('üîç DEBUG processBulkExtraction: selectedTimes =', times, 'length =', times ? times.length : 0);
            console.log('üîç DEBUG processBulkExtraction: window.appData =', window.appData);
            
            if (!times || times.length === 0) {
                alert('Please add at least one time point first! Use "+ Add Current Time" or auto-generate time points.\n\nDebug: selectedTimes.length = ' + (times ? times.length : 'null'));
                debug('ERROR: No time points found. selectedTimes = ' + JSON.stringify(window.appData.selectedTimes), 'error');
                return;
            }
            
            // Validate time points before processing
            const videoPaths = selectedVideos.map(v => v.path);
            validateBulkTimePoints(videoPaths, times).then(() => {
                startBulkExtraction(selectedVideos, times);
            }).catch(err => {
                alert('Validation failed: ' + err.message);
            });
        }
    }
    
    if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', initExtractBtn);
    } else {
        setTimeout(initExtractBtn, 1000);
    }
})();

// Format selector - show/hide PDF-specific options
(function() {
    function initFormatSelector() {
        const formatSelect = document.getElementById('outputFormat');
        const pdfSettingsContainer = document.getElementById('pdfSettingsContainer');
        const imagesPerPageContainer = document.getElementById('imagesPerPageContainer');
        
        if (formatSelect) {
            formatSelect.onchange = function() {
                const format = this.value;
                if (format === 'pdf') {
                    pdfSettingsContainer.style.display = 'block';
                    imagesPerPageContainer.style.display = 'block';
                } else {
                    // DOCX - hide PDF-specific settings
                    pdfSettingsContainer.style.display = 'none';
                    imagesPerPageContainer.style.display = 'block'; // Still show for DOCX layout reference
                }
            };
            // Trigger initial state
            formatSelect.onchange();
        }
    }
    
    if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', initFormatSelector);
    } else {
        setTimeout(initFormatSelector, 500);
    }
})();

// Generate Document (PDF or DOCX)
(function() {
    function initGenerateBtn() {
        const btn = document.getElementById('generateOutputBtn');
        if (!btn) return;
        
        const newBtn = btn.cloneNode(true);
        btn.parentNode.replaceChild(newBtn, btn);
        const freshBtn = document.getElementById('generateOutputBtn');
        
        // Define functions before using them
        function processBulkDocumentGeneration() {
            if (!window.appData.batchResults) {
                window.appData.batchResults = [];
            }
            const batchResults = window.appData.batchResults;
            if (!batchResults || batchResults.length === 0) {
                alert('No batch extraction results found. Please extract frames first!');
                return;
            }
            
            const successfulResults = batchResults.filter(r => r.status === 'completed' && r.extractedImages && r.extractedImages.length > 0);
            if (successfulResults.length === 0) {
                alert('No videos have extracted frames. Please extract frames first!');
                return;
            }
            
            startBulkDocumentGeneration(successfulResults);
        }
        
        function processSingleDocumentGeneration() {
            const images = window.appData.extractedImages;
            if (!images || images.length === 0) {
                alert('Please extract frames first!');
                return;
            }
            
            if (!window.appData.videoPath) {
                alert('Video path not found');
                return;
            }
            
            const layout = document.getElementById('layoutSelect').value || 'grid';
            const imagesPerPage = parseInt(document.getElementById('imagesPerPage').value) || 4;
            
            debug(`Generating both PDF and DOCX from ${images.length} images`, 'info');
            
            document.getElementById('progressContainer').style.display = 'block';
            document.getElementById('progressFill').style.width = '0%';
            document.getElementById('progressText').textContent = 'Generating PDF and DOCX...';
            
            // Store results
            const results = { pdf: null, docx: null };
            let completed = 0;
            const total = 2;
            
            function updateProgress() {
                completed++;
                const percent = Math.round((completed / total) * 100);
                document.getElementById('progressFill').style.width = percent + '%';
                
                if (completed === total) {
                    document.getElementById('progressText').textContent = 'PDF and DOCX generated!';
                    setTimeout(() => {
                        document.getElementById('progressContainer').style.display = 'none';
                        showResults(results);
                    }, 1000);
                } else {
                    document.getElementById('progressText').textContent = `Generating... (${completed}/${total})`;
                }
            }
            
            function showResults(results) {
                let html = '<div style="padding: 15px; background: #1e3a1e; border: 1px solid #2d5a2d; border-radius: 6px; margin-top: 15px; color: #e0e0e0;">';
                html += '<strong>‚úÖ Documents Generated Successfully!</strong><br><br>';
                
                if (results.pdf) {
                    const pdfUrl = `/v2p-formatter/download?path=${encodeURIComponent(results.pdf.file_path)}`;
                    html += `<a href="${pdfUrl}" download style="display: inline-block; padding: 10px 20px; background: #667eea; color: white; text-decoration: none; border-radius: 6px; font-weight: bold; margin-right: 10px; margin-bottom: 10px;">
                        üìÑ Download PDF: ${results.pdf.filename}
                    </a>`;
                }
                
                if (results.docx) {
                    const docxUrl = `/v2p-formatter/download?path=${encodeURIComponent(results.docx.file_path)}`;
                    html += `<a href="${docxUrl}" download style="display: inline-block; padding: 10px 20px; background: #667eea; color: white; text-decoration: none; border-radius: 6px; font-weight: bold; margin-right: 10px; margin-bottom: 10px;">
                        üìù Download DOCX: ${results.docx.filename}
                    </a>`;
                }
                
                html += '<br><br><small style="color: #999;">Both files saved in the video output folder</small>';
                html += '</div>';
                
                document.getElementById('results').innerHTML = html;
                document.getElementById('results').style.display = 'block';
            }
        }
        
        // Set onclick handler AFTER functions are defined
        freshBtn.onclick = function() {
            // Check if bulk mode
            if (window.appData.bulkMode) {
                processBulkDocumentGeneration();
            } else {
                processSingleDocumentGeneration();
            }
        };
    }
    
    // Initialize on page load
    if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', initGenerateBtn);
    } else {
        setTimeout(initGenerateBtn, 1000);
    }
})();

// Start bulk document generation
async function startBulkDocumentGeneration(successfulResults) {
    const layout = document.getElementById('layoutSelect').value || 'grid';
    const imagesPerPage = parseInt(document.getElementById('imagesPerPage').value) || 4;
    const outputFormat = document.getElementById('outputFormat').value || 'both';
    
    // Determine which formats to generate
    const generatePDF = outputFormat === 'pdf' || outputFormat === 'both';
    const generateDOCX = outputFormat === 'docx' || outputFormat === 'both';
    
    // Show batch progress container
    const batchContainer = document.getElementById('batchProgressContainer');
    const batchFill = document.getElementById('batchProgressFill');
    const batchText = document.getElementById('batchProgressText');
    const batchStatusList = document.getElementById('batchVideoStatusList');
    
    if (!batchContainer || !batchFill || !batchText || !batchStatusList) {
        alert('Batch progress UI elements not found. Please refresh the page.');
        return;
    }
    
    batchContainer.style.display = 'block';
    const progressContainer = document.getElementById('progressContainer');
    if (progressContainer) progressContainer.style.display = 'none';
    batchFill.style.width = '0%';
    batchText.textContent = `Generating documents for video 1 of ${successfulResults.length}...`;
    
    // Clear and populate status list
    batchStatusList.innerHTML = '';
    successfulResults.forEach((result) => {
        const statusItem = document.createElement('div');
        statusItem.id = `batch-doc-status-${result.index}`;
        statusItem.style.cssText = 'padding: 10px; margin: 5px 0; background: #2a2a2a; border-radius: 4px; border-left: 4px solid #666; display: flex; align-items: center; justify-content: space-between;';
        const videoName = result.video ? result.video.name : result.filename || 'Unknown';
        statusItem.innerHTML = `
            <div>
                <strong style="color: #e0e0e0;">${videoName}</strong>
                <div style="color: #999; font-size: 12px; margin-top: 2px;">‚è∏Ô∏è Pending</div>
            </div>
        `;
        batchStatusList.appendChild(statusItem);
    });
    
    // Process videos sequentially
    let completed = 0;
    const totalVideos = successfulResults.length;
    // Calculate total operations based on selected format
    const operationsPerVideo = (generatePDF ? 1 : 0) + (generateDOCX ? 1 : 0);
    const totalOperations = totalVideos * operationsPerVideo;
    
    if (totalOperations === 0) {
        alert('Please select at least one output format (PDF or DOCX)');
        batchContainer.style.display = 'none';
        return;
    }
    
    for (let i = 0; i < successfulResults.length; i++) {
        const result = successfulResults[i];
        const videoName = result.video ? result.video.name : result.filename || 'Unknown';
        const videoPath = result.video ? result.video.path : result.videoPath;
        const statusItem = document.getElementById(`batch-doc-status-${result.index}`);
        
        if (!statusItem) continue;
        
        batchText.textContent = `Generating documents for video ${i + 1} of ${totalVideos}: ${videoName}`;
        
        // Update status to processing
        statusItem.style.borderLeftColor = '#667eea';
        statusItem.innerHTML = `
            <div>
                <strong style="color: #e0e0e0;">${videoName}</strong>
                <div style="color: #667eea; font-size: 12px; margin-top: 2px;">‚è≥ Generating...</div>
            </div>
        `;
        
        const videoResults = { pdf: null, docx: null };
        let pdfError = null;
        let docxError = null;
        
        try {
            // Generate PDF if requested
            if (generatePDF) {
                try {
                    const pdfResponse = await fetch('/v2p-formatter/generate_pdf', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            video_path: videoPath,
                            image_paths: result.extractedImages,
                            layout: layout,
                            images_per_page: imagesPerPage
                        })
                    });
                    
                    const pdfData = await pdfResponse.json();
                    if (pdfData.success) {
                        videoResults.pdf = { file_path: pdfData.pdf_path || pdfData.file_path, filename: pdfData.filename };
                        debug(`PDF generated for ${videoName}: ${pdfData.filename}`, 'success');
                    } else {
                        pdfError = pdfData.error || 'Unknown error';
                        debug(`Error generating PDF for ${videoName}: ${pdfError}`, 'error');
                    }
                } catch (err) {
                    pdfError = err.message;
                    debug(`Network error generating PDF for ${videoName}: ${err.message}`, 'error');
                }
                completed++;
                const progressPercent = Math.round((completed / totalOperations) * 100);
                batchFill.style.width = progressPercent + '%';
            }
            
            // Generate DOCX if requested
            if (generateDOCX) {
                try {
                    const docxResponse = await fetch('/v2p-formatter/generate_docx', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            video_path: videoPath,
                            image_paths: result.extractedImages,
                            images_per_page: imagesPerPage
                        })
                    });
                    
                    const docxData = await docxResponse.json();
                    if (docxData.success) {
                        videoResults.docx = { file_path: docxData.docx_path || docxData.file_path, filename: docxData.filename };
                        debug(`DOCX generated for ${videoName}: ${docxData.filename}`, 'success');
                    } else {
                        docxError = docxData.error || 'Unknown error';
                        debug(`Error generating DOCX for ${videoName}: ${docxError}`, 'error');
                    }
                } catch (err) {
                    docxError = err.message;
                    debug(`Network error generating DOCX for ${videoName}: ${err.message}`, 'error');
                }
                completed++;
                const progressPercent = Math.round((completed / totalOperations) * 100);
                batchFill.style.width = progressPercent + '%';
            }
            
            // Update result in batchResults
            if (!window.appData.batchResults) {
                window.appData.batchResults = [];
            }
            const batchIndex = window.appData.batchResults.findIndex(r => r.index === result.index);
            if (batchIndex >= 0) {
                window.appData.batchResults[batchIndex].generatedDocuments = videoResults;
            }
            
            // Update status based on results
            const hasPDF = videoResults.pdf !== null;
            const hasDOCX = videoResults.docx !== null;
            const hasAnySuccess = hasPDF || hasDOCX;
            const hasAllRequested = (generatePDF ? hasPDF : true) && (generateDOCX ? hasDOCX : true);
            
            let statusColor, statusText, statusIcon;
            if (!hasAnySuccess) {
                statusColor = '#ff6b6b';
                statusIcon = '‚ùå';
                statusText = 'Failed';
            } else if (!hasAllRequested) {
                statusColor = '#ffa500';
                statusIcon = '‚ö†Ô∏è';
                const parts = [];
                if (hasPDF) parts.push('PDF');
                if (hasDOCX) parts.push('DOCX');
                statusText = `Partial: ${parts.join(', ')}`;
            } else {
                statusColor = '#4ade80';
                statusIcon = '‚úÖ';
                const parts = [];
                if (hasPDF) parts.push('PDF');
                if (hasDOCX) parts.push('DOCX');
                statusText = `Complete: ${parts.join(', ')}`;
            }
            
            statusItem.style.borderLeftColor = statusColor;
            statusItem.innerHTML = `
                <div>
                    <strong style="color: #e0e0e0;">${videoName}</strong>
                    <div style="color: ${statusColor}; font-size: 12px; margin-top: 2px;">${statusIcon} ${statusText}</div>
                    ${pdfError ? `<div style="color: #ff6b6b; font-size: 11px; margin-top: 2px;">PDF: ${pdfError}</div>` : ''}
                    ${docxError ? `<div style="color: #ff6b6b; font-size: 11px; margin-top: 2px;">DOCX: ${docxError}</div>` : ''}
                </div>
            `;
            
        } catch (err) {
            debug(`Unexpected error generating documents for ${videoName}: ${err.message}`, 'error');
            statusItem.style.borderLeftColor = '#ff6b6b';
            statusItem.innerHTML = `
                <div>
                    <strong style="color: #e0e0e0;">${videoName}</strong>
                    <div style="color: #ff6b6b; font-size: 12px; margin-top: 2px;">‚ùå Error: ${err.message}</div>
                </div>
            `;
            // Mark operations as completed to maintain progress
            completed += operationsPerVideo;
            const progressPercent = Math.round((completed / totalOperations) * 100);
            batchFill.style.width = progressPercent + '%';
        }
    }
    
    // All done
    batchText.textContent = `Batch document generation complete! ${totalVideos} video(s) processed.`;
    
    // Show results
    showBulkDocumentGenerationResults(successfulResults);
}

function showBulkDocumentGenerationResults(successfulResults) {
    let html = '<div style="padding: 15px; background: #1e3a1e; border: 1px solid #2d5a2d; border-radius: 6px; margin-top: 15px; color: #e0e0e0;">';
    html += '<strong>‚úÖ Batch Document Generation Complete!</strong><br><br>';
    html += `<strong>Generated documents for ${successfulResults.length} video(s):</strong><br><br>`;
    
    successfulResults.forEach(result => {
        const batchResult = window.appData.batchResults.find(r => r.index === result.index);
        if (batchResult && batchResult.generatedDocuments) {
            const videoName = result.video ? result.video.name : result.filename || 'Unknown';
            html += `<div style="margin-bottom: 15px; padding: 10px; background: #2a3a4a; border-radius: 4px;">`;
            html += `<strong>${videoName}:</strong><br>`;
            
            if (batchResult.generatedDocuments.pdf) {
                const pdfUrl = `/v2p-formatter/download?path=${encodeURIComponent(batchResult.generatedDocuments.pdf.file_path)}`;
                html += `<a href="${pdfUrl}" download style="display: inline-block; padding: 8px 16px; background: #667eea; color: white; text-decoration: none; border-radius: 4px; font-weight: bold; margin-right: 8px; margin-top: 8px;">
                    üìÑ ${batchResult.generatedDocuments.pdf.filename}
                </a>`;
            }
            
            if (batchResult.generatedDocuments.docx) {
                const docxUrl = `/v2p-formatter/download?path=${encodeURIComponent(batchResult.generatedDocuments.docx.file_path)}`;
                html += `<a href="${docxUrl}" download style="display: inline-block; padding: 8px 16px; background: #667eea; color: white; text-decoration: none; border-radius: 4px; font-weight: bold; margin-right: 8px; margin-top: 8px;">
                    üìù ${batchResult.generatedDocuments.docx.filename}
                </a>`;
            }
            
            html += `</div>`;
        }
    });
    
    html += '</div>';
    
    const resultsDiv = document.getElementById('results');
    if (resultsDiv) {
        resultsDiv.innerHTML = html;
        resultsDiv.style.display = 'block';
        // Scroll to results
        resultsDiv.scrollIntoView({ behavior: 'smooth', block: 'start' });
    }
}

// Initialize dropdown handlers on page load
document.addEventListener('DOMContentLoaded', function() {
    // Set up dropdown event listeners
    const qualificationSelect = document.getElementById('qualificationSelect');
    const learnerSelect = document.getElementById('learnerSelect');
    
    if (qualificationSelect) {
        qualificationSelect.addEventListener('change', handleQualificationChange);
    }
    
    if (learnerSelect) {
        learnerSelect.addEventListener('change', handleLearnerChange);
    }
    
    // Sort by control
    const sortBySelect = document.getElementById('sortBy');
    if (sortBySelect) {
        sortBySelect.value = window.appData.sortBy || 'name';
        sortBySelect.addEventListener('change', function() {
            window.appData.sortBy = this.value;
            // Re-render video list if files are loaded
            if (window.appData.availableFiles && window.appData.availableFiles.length > 0) {
                renderVideoList(window.appData.availableFiles);
            }
        });
    }
    
    // Thumbnails per row control
    const thumbnailsPerRowSelect = document.getElementById('thumbnailsPerRow');
    if (thumbnailsPerRowSelect) {
        // Force default to 3 if not set
        if (!window.appData.thumbnailsPerRow || window.appData.thumbnailsPerRow < 3) {
            window.appData.thumbnailsPerRow = 3;
        }
        thumbnailsPerRowSelect.value = window.appData.thumbnailsPerRow;
        thumbnailsPerRowSelect.addEventListener('change', function() {
            const value = parseInt(this.value) || 3;
            window.appData.thumbnailsPerRow = Math.max(value, 3); // Ensure minimum 3
            // Re-render video list if files are loaded
            if (window.appData.availableFiles && window.appData.availableFiles.length > 0) {
                renderVideoList(window.appData.availableFiles);
            }
        });
    }
    
    // Auto-load if both are selected (from URL parameters)
    const urlParams = new URLSearchParams(window.location.search);
    const selectedQualification = urlParams.get('qualification');
    const selectedLearner = urlParams.get('learner');
    
    if (selectedQualification && qualificationSelect) {
        qualificationSelect.value = selectedQualification;
        handleQualificationChange();
        
        // Wait a bit for learner dropdown to populate, then set learner and load files
        setTimeout(() => {
            if (selectedLearner && learnerSelect) {
                learnerSelect.value = selectedLearner;
                // Load files after both dropdowns are set
                if (typeof window.loadFiles === 'function') {
                    window.loadFiles();
                } else if (typeof loadFileTree === 'function') {
                    loadFileTree();
                }
            }
        }, 500); // Increased timeout to ensure dropdown is populated
    } else {
        // No selection - show empty message
        const fileTreeContent = document.getElementById('fileTreeContent');
        if (fileTreeContent) {
            fileTreeContent.innerHTML = '<p style="text-align: center; color: #999; padding: 20px;">Please select both qualification and learner to view files</p>';
        }
    }
});

// Auto-generate PDF after frame extraction
function generatePDFAuto() {
    if (!window.appData.extractedImages || window.appData.extractedImages.length === 0) {
        return;
    }
    
    const layout = document.getElementById('layoutSelect')?.value || 'grid';
    const imagesPerPage = parseInt(document.getElementById('imagesPerPage')?.value || 4);
    
    document.getElementById('progressContainer').style.display = 'block';
    document.getElementById('progressFill').style.width = '0%';
    document.getElementById('progressText').textContent = 'Generating PDF...';
    
    fetch('/v2p-formatter/generate_pdf', {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json'
        },
        body: JSON.stringify({
            video_path: window.appData.videoPath,
            image_paths: window.appData.extractedImages,
            layout: layout,
            images_per_page: imagesPerPage
        })
    })
    .then(response => response.json())
    .then(data => {
        if (data.success) {
            document.getElementById('progressFill').style.width = '100%';
            document.getElementById('progressText').textContent = 'PDF generated successfully!';
            
            setTimeout(() => {
                document.getElementById('progressContainer').style.display = 'none';
                showPDFResults(data);
            }, 1000);
        } else {
            document.getElementById('progressContainer').style.display = 'none';
            alert('Error: ' + (data.error || 'Failed to generate PDF'));
            debug('PDF generation error: ' + (data.error || 'Unknown'), 'error');
        }
    })
    .catch(error => {
        document.getElementById('progressContainer').style.display = 'none';
        console.error('PDF generation error:', error);
        alert('Failed to generate PDF: ' + error.message);
        debug('PDF generation error: ' + error.message, 'error');
    });
}

// Show PDF results with proper formatting (matching image-to-pdf)
function showPDFResults(data) {
    const resultsDiv = document.getElementById('results');
    if (!resultsDiv) return;
    
    // Check if this is bulk results (array of results)
    const isBulk = Array.isArray(data) || (data.results && Array.isArray(data.results));
    const results = isBulk ? (data.results || data) : [data];
    
    let html = '<div style="padding: 20px; background: #2a2a2a; border-radius: 6px; margin-top: 20px;">';
    
    if (isBulk && results.length > 1) {
        html += `<h3 style="color: #e0e0e0; margin-top: 0;">‚úÖ ${results.length} PDFs Generated Successfully!</h3>`;
    } else {
        html += '<h3 style="color: #e0e0e0; margin-top: 0;">‚úÖ PDF Generated Successfully!</h3>';
    }
    
    // Process each result
    results.forEach((result, index) => {
        if (isBulk && results.length > 1) {
            html += `<h4 style="color: #e0e0e0; margin-top: ${index > 0 ? '20px' : '0'}; margin-bottom: 15px; padding-bottom: 10px; border-bottom: 1px solid #555;">PDF ${index + 1} of ${results.length}</h4>`;
        }
        
        // Output Filename
        if (result.filename) {
            html += '<p style="color: #e0e0e0; margin-bottom: 15px;"><strong>Output Filename:</strong> <span style="color: #999; font-family: monospace;">' + escapeHtml(result.filename) + '</span></p>';
        }
        
        // Add output folder path
        if (result.output_folder_path) {
            html += '<p style="margin-bottom: 15px;"><strong style="color: #e0e0e0;">Output Folder:</strong></p>';
            html += `<p style="margin-bottom: 15px; padding: 10px; background: #1e1e1e; border-radius: 4px; word-break: break-all; font-family: monospace; color: #999; font-size: 12px;">${escapeHtml(result.output_folder_path)}</p>`;
            html += `<p style="margin-bottom: 20px;"><a href="#" onclick="openFolderInFinder('${result.output_folder_path.replace(/'/g, "\\'")}'); return false;" style="color: #667eea; text-decoration: underline; font-weight: 500; cursor: pointer;">üìÅ Open Output Folder</a></p>`;
            html += '<hr style="border: none; border-top: 1px solid #555; margin: 15px 0;">';
        }
        
        // Add PDF file path (clickable to open in Finder) - matching image-to-pdf format
        if (result.file_path) {
            // Extract directory from file path for Finder link
            const fileDir = result.file_path.substring(0, result.file_path.lastIndexOf('/'));
            html += '<p style="color: #e0e0e0; margin-bottom: 10px;"><strong>File Path:</strong> <a href="#" onclick="openFolderInFinder(\'' + fileDir.replace(/'/g, "\\'") + '\'); return false;" style="color: #667eea; text-decoration: underline; cursor: pointer;">' + escapeHtml(result.file_path) + '</a></p>';
        }
        
        // Add PDF links - matching image-to-pdf format exactly
        const pdfRelativePath = result.pdf_relative_path || result.file_path;
        if (pdfRelativePath) {
            html += '<p style="color: #e0e0e0; margin-bottom: 10px;"><strong>PDF:</strong> <a href="#" onclick="openFileInPreview(\'' + pdfRelativePath.replace(/'/g, "\\'") + '\'); return false;" style="color: #667eea; text-decoration: underline; cursor: pointer;">üìÑ Open PDF</a></p>';
        }
        
        if (index < results.length - 1) {
            html += '<hr style="border: none; border-top: 1px solid #555; margin: 20px 0;">';
        }
    });
    
    html += '</div>';
    resultsDiv.innerHTML = html;
    resultsDiv.style.display = 'block';
}

// Utility function to escape HTML
function escapeHtml(text) {
    const div = document.createElement('div');
    div.textContent = text;
    return div.innerHTML;
}
</script>
{% endblock %}
